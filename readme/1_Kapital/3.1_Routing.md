# Routing (Yönlendirme)

Uygulamanız bir istek aldığında, yanıtı oluşturmak için bir controller aksiyonunu çağırır. Routing (yönlendirme) yapılandırması, her gelen URL için hangi aksiyonun çalıştırılacağını tanımlar. Ayrıca SEO dostu URL'ler oluşturmak gibi başka faydalı özellikler de sağlar (örneğin, /read/intro-to-symfony yerine index.php?article_id=57).

## Route Oluşturmak

Route'lar YAML, XML, PHP veya attribute ile yapılandırılabilir. Tüm formatlar aynı özellikleri ve performansı sunar, favorinizi seçebilirsiniz. Symfony, attribute kullanımını önerir çünkü route ve controller'ı aynı yerde tutmak daha pratiktir.

### Attribute ile Route Oluşturmak

PHP attribute'ları, route'ları ilgili controller kodunun yanında tanımlamanıza olanak tanır.

Bunları kullanmadan önce projenize biraz yapılandırma eklemeniz gerekir. Projeniz Symfony Flex kullanıyorsa, bu dosya zaten oluşturulmuştur. Aksi halde, aşağıdaki dosyayı elle oluşturun:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('# config/routes/attributes.yaml\ncontrollers:\n    resource:\n        path: ../../src/Controller/\n        namespace: App\\Controller\n    type: attribute\nkernel:\n    resource: App\\Kernel\n    type: attribute')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-yaml"># config/routes/attributes.yaml
controllers:
    resource:
        path: ../../src/Controller/
        namespace: App\Controller
    type: attribute
kernel:
    resource: App\Kernel
    type: attribute</code></pre>
  </div>
</div>

Bu yapılandırma, Symfony'ye App\Controller namespace'inde ve src/Controller/ dizininde tanımlanan sınıflardaki attribute ile tanımlanmış route'ları aramasını söyler. Kernel de controller olarak davranabilir, bu özellikle Symfony'yi mikroframework olarak kullanan küçük uygulamalar için faydalıdır.

Uygulamanızda /blog URL'si için bir route tanımlamak istediğinizi varsayalım. Bunun için aşağıdaki gibi bir controller sınıfı oluşturun:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('// src/Controller/BlogController.php\nnamespace App\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n\nclass BlogController extends AbstractController\n{\n    #[Route(\'/blog\', name: \'blog_list\')]\n    public function list(): Response\n    {\n        // ...\n    }\n}')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class BlogController extends AbstractController
{ #[Route('/blog', name: 'blog_list')]
public function list(): Response
{
// ...
}
}</code></pre>

  </div>
</div>

Bu yapılandırma, kullanıcı /blog URL'sini istediğinde eşleşen blog_list adlı bir route tanımlar. Eşleşme olduğunda uygulama BlogController sınıfının list() metodunu çalıştırır.

Bir URL'nin query string'i route eşleşmesinde dikkate alınmaz. Bu örnekte, /blog?foo=bar ve /blog?foo=bar&bar=foo gibi URL'ler de blog_list route'u ile eşleşir.

Aynı dosyada birden fazla PHP sınıfı tanımlarsanız, Symfony sadece ilk sınıfın route'larını yükler, diğerlerini görmezden gelir.

Route adı (blog_list) şimdilik önemli değil, ama ileride URL üretirken önemli olacak. Sadece her route adının uygulamada benzersiz olması gerektiğini unutmayın.

# YAML ile Route Tanımlama

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('blog_list:\n    path: /blog\n    # the controller value has the format \'controller_class::method_name\'\n    controller: App\\Controller\\BlogController::list')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-yaml">blog_list:
    path: /blog
    # the controller value has the format 'controller_class::method_name'
    controller: App\Controller\BlogController::list</code></pre>
  </div>
</div>

# XML ile Route Tanımlama

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<routes xmlns=\"http://symfony.com/schema/routing\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/routing\n        https://symfony.com/schema/routing/routing-1.0.xsd\">\n    <route id=\"blog_list\" path=\"/blog\"\n           controller=\"App\\Controller\\BlogController::list\"/>\n</routes>')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-xml"><?xml version="1.0" encoding="UTF-8" ?>
<routes xmlns="http://symfony.com/schema/routing"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/routing
        https://symfony.com/schema/routing/routing-1.0.xsd">
    <route id="blog_list" path="/blog"
           controller="App\Controller\BlogController::list"/>
</routes></code></pre>
  </div>
</div>

# PHP ile Route Tanımlama

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('use App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\nreturn function (RoutingConfigurator $routes): void {\n    $routes->add(\'blog_list\', \'/blog\')\n        // the controller value has the format [controller_class, method_name]\n        ->controller([BlogController::class, \'list\'])\n    ;\n};')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return function (RoutingConfigurator $routes): void {
$routes->add('blog_list', '/blog')
// the controller value has the format [controller_class, method_name]
->controller([BlogController::class, 'list'])
;
};</code></pre>

  </div>
</div>

Symfony varsayılan olarak YAML ve PHP formatında tanımlanan route'ları yükler. XML formatında route tanımlarsanız, src/Kernel.php dosyasını güncellemeniz gerekir.

## HTTP Metodlarını Eşleştirmek

Varsayılan olarak, route'lar tüm HTTP fiillerini (GET, POST, PUT, vb.) eşleştirir. Her route'un hangi fiillere yanıt vereceğini kısıtlamak için methods seçeneğini kullanın:

# Attribute ile

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('namespace App\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Attribute\\Route;\n\nclass BlogApiController extends AbstractController\n{\n    #[Route(\'/api/posts/{id}\', methods: [\'GET\', \'HEAD\'])]\n    public function show(int $id): Response\n    {\n        // ... return a JSON response with the post\n    }\n\n    #[Route(\'/api/posts/{id}\', methods: [\'PUT\'])]\n    public function edit(int $id): Response\n    {\n        // ... edit a post\n    }\n}')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class BlogApiController extends AbstractController
{
#[Route('/api/posts/{id}', methods: ['GET', 'HEAD'])]
public function show(int $id): Response
{
// ... return a JSON response with the post
}

    #[Route('/api/posts/{id}', methods: ['PUT'])]
    public function edit(int $id): Response
    {
        // ... edit a post
    }

}</code></pre>

  </div>
</div>

# YAML ile

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('api_post_show:\n    path:       /api/posts/{id}\n    controller: App\\Controller\\BlogApiController::show\n    methods:    GET|HEAD\n\napi_post_edit:\n    path:       /api/posts/{id}\n    controller: App\\Controller\\BlogApiController::edit    methods:    PUT')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-yaml">api_post_show:
    path:       /api/posts/{id}
    controller: App\Controller\BlogApiController::show
    methods:    GET|HEAD

api_post_edit:
path: /api/posts/{id}
controller: App\Controller\BlogApiController::edit
methods: PUT</code></pre>

  </div>
</div>

# XML ile

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('<?xml version=\"1.0\" encoding=\"UTF-8\" ?><routes xmlns=\"http://symfony.com/schema/routing\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://symfony.com/schema/routing\n        https://symfony.com/schema/routing/routing-1.0.xsd\">   <route id=\"api_post_show\" path=\"/api/posts/{id}\"\n        controller=\"App\\Controller\\BlogApiController::show\"\n        methods=\"GET|HEAD\"/>   <route id=\"api_post_edit\" path=\"/api/posts/{id}\"\n        controller=\"App\\Controller\\BlogApiController::edit\"\n        methods=\"PUT\"/></routes>')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-xml"><?xml version="1.0" encoding="UTF-8" ?>
<routes xmlns="http://symfony.com/schema/routing"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/routing
        https://symfony.com/schema/routing/routing-1.0.xsd">
    <route id="api_post_show" path="/api/posts/{id}"
        controller="App\Controller\BlogApiController::show"
        methods="GET|HEAD"/>

    <route id="api_post_edit" path="/api/posts/{id}"
        controller="App\Controller\BlogApiController::edit"
        methods="PUT"/>

</routes></code></pre>

  </div>
</div>

<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
  <span style="font-size:24px; margin-right:12px;">💡</span>
  <span style="color:#222; font-size:16px;">HTML formlar sadece GET ve POST metodlarını destekler. Bir route'u HTML formundan farklı bir metodla çağırmak istiyorsanız, kullanmak istediğiniz metodu belirten <b>_method</b> adlı gizli bir alan ekleyin (örneğin <code>&lt;input type="hidden" name="_method" value="PUT"&gt;</code>). Symfony Forms ile form oluşturuyorsanız, <b>framework.http_method_override</b> seçeneği <b>true</b> ise bu otomatik olarak yapılır.</span>
</div>

## Ortam Eşleştirme (Matching Environments)

Bir route'u sadece mevcut yapılandırma ortamı verilen değere eşleştiğinde kaydetmek için env seçeneğini kullanın:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('use App\\Controller\\DefaultController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\nreturn function (RoutingConfigurator $routes): void {\n    $routes->add(\'tools\', \'/tools\')\n        ->controller([DefaultController::class, \'developerTools\'])\n        ->env(\'dev\')\n    ;\n};')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">use App\Controller\DefaultController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return function (RoutingConfigurator $routes): void {
$routes->add('tools', '/tools')
->controller([DefaultController::class, 'developerTools'])
->env('dev')
;
};</code></pre>

  </div>
</div>

## İfade Eşleştirme (Matching Expressions)

Bazı route'ların rastgele eşleşme mantığına göre eşleşmesini istiyorsanız condition seçeneğini kullanın:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('use App\\Controller\\DefaultController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\nreturn function (RoutingConfigurator $routes): void {\n    $routes->add(\'contact\', \'/contact\')\n        ->controller([DefaultController::class, \'contact\'])\n        ->condition(\'context.getMethod() in [\"GET\", \"HEAD\"] and request.headers.get(\"User-Agent\") matches \/firefox\/i\' )\n    ;\n    $routes->add(\'post_show\', \'/posts/{id}\')\n        ->controller([DefaultController::class, \'showPost\'])\n        ->condition(\'params[\"id\"] < 1000\')\n    ;\n};')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">use App\Controller\DefaultController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return function (RoutingConfigurator $routes): void {
$routes->add('contact', '/contact')
->controller([DefaultController::class, 'contact'])
->condition('context.getMethod() in ["GET", "HEAD"] and request.headers.get("User-Agent") matches "/firefox/i"')
;
$routes->add('post_show', '/posts/{id}')
->controller([DefaultController::class, 'showPost'])
->condition('params["id"] < 1000')
;
};</code></pre>

  </div>
</div>

condition seçeneğinin değeri, geçerli expression language sözdizimini kullanan bir ifadedir ve Symfony tarafından oluşturulan şu değişkenleri kullanabilir:

-   <b>context</b>: Route eşleşmesinde temel bilgileri tutan RequestContext örneği.
-   <b>request</b>: Geçerli isteği temsil eden Symfony Request nesnesi.
-   <b>params</b>: Geçerli route için eşleşen parametrelerin dizisi.

Ayrıca şu fonksiyonları da kullanabilirsiniz:

-   <b>env(string $name)</b>: Ortam değişkeni değerini döndürür.
-   <b>service(string $alias)</b>: Routing condition servisini döndürür.

Önce, route koşullarında kullanmak istediğiniz servislere #[AsRoutingConditionService] attribute'u veya routing.condition_service etiketi ekleyin:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('use Symfony\\Bundle\\FrameworkBundle\\Routing\\Attribute\\AsRoutingConditionService;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n#[AsRoutingConditionService(alias: \'route_checker\')]\nclass RouteChecker\n{\n    public function check(Request $request): bool\n    {\n        // ...\n    }\n}')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">use Symfony\Bundle\FrameworkBundle\Routing\Attribute\AsRoutingConditionService;
use Symfony\Component\HttpFoundation\Request;

#[AsRoutingConditionService(alias: 'route_checker')]
class RouteChecker
{
public function check(Request $request): bool
{
// ...
}
}</code></pre>

  </div>
</div>

Sonra, service() fonksiyonunu kullanarak bu servisi koşul içinde referans verin:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('#[Route(condition: "service(\'route_checker\').check(request)")]\n#[Route(condition: "service(\'App\\\\Service\\\\RouteChecker\').check(request)")]')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">#[Route(condition: "service('route_checker').check(request)")]
#[Route(condition: "service('App\\Service\\RouteChecker').check(request)")]</code></pre>
  </div>
</div>

Arka planda, ifadeler ham PHP'ye derlenir. Bu nedenle, condition anahtarını kullanmak, altta yatan PHP'nin çalışması dışında ekstra bir yük getirmez.

Koşullar, URL üretirken dikkate alınmaz (bu makalenin ilerleyen kısmında açıklanacak).

<div style="background:#f7b955; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
  <span style="font-size:24px; margin-right:12px;">⚠️</span>
  <span style="color:#222; font-size:16px;">Koşullar, URL üretirken dikkate alınmaz (bu makalenin ilerleyen kısmında açıklanacak).</span>
</div>

## Route'ları Debug Etmek

Uygulamanız büyüdükçe, çok fazla route olacak. Symfony, routing sorunlarını debug etmek için bazı komutlar içerir. Öncelikle, debug:router komutu uygulamanızdaki tüm route'ları Symfony'nin değerlendirdiği sırayla listeler:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('php bin/console debug:router')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-bash">php bin/console debug:router</code></pre>
  </div>
</div>

---

Name Method Scheme Host Path

---

homepage ANY ANY ANY /
contact GET ANY ANY /contact
contact_process POST ANY ANY /contact
article_show ANY ANY ANY /articles/{\_locale}/{year}/{title}.{\_format}
blog ANY ANY ANY /blog/{page}
blog_show ANY ANY ANY /blog/{slug}

---

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('php bin/console debug:router --show-aliases')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-bash">php bin/console debug:router --show-aliases</code></pre>
  </div>
</div>

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('php bin/console debug:router --method=GET')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-bash">php bin/console debug:router --method=GET</code></pre>
  </div>
</div>

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('php bin/console debug:router --method=ANY')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-bash">php bin/console debug:router --method=ANY</code></pre>
  </div>
</div>

7.3

--method seçeneği Symfony 7.3 ile gelmiştir.

Bir route'un adını (veya adının bir kısmını) bu argümana geçirerek route detaylarını yazdırabilirsiniz:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('php bin/console debug:router app_lucky_number')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-bash">php bin/console debug:router app_lucky_number</code></pre>
  </div>
</div>

+-------------+---------------------------------------------------------+
| Property | Value |
+-------------+---------------------------------------------------------+
| Route Name | app_lucky_number |
| Path | /lucky/number/{max} |
| ... | ... |
| Options | compiler_class: Symfony\Component\Routing\RouteCompiler |
| | utf8: true |
+-------------+---------------------------------------------------------+

Diğer komut router:match ve verilen URL ile hangi route'un eşleşeceğini gösterir. Beklediğiniz controller aksiyonu çalışmıyorsa nedenini bulmak için faydalıdır:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('php bin/console router:match /lucky/number/8')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-bash">php bin/console router:match /lucky/number/8</code></pre>
  </div>
</div>

[OK] Route "app_lucky_number" matches

## Route Parametreleri

Önceki örneklerde URL hiç değişmiyordu (ör: /blog). Ancak, genellikle URL'nin bazı kısımlarının değişken olması gerekir. Örneğin, bir blog yazısını göstermek için URL'de başlık veya slug bulunur (ör: /blog/ilk-yazi veya /blog/symfony-hakkinda).

Symfony route'larında değişken kısımlar { } ile yazılır. Örneğin, blog yazısı içeriğini gösterecek route şöyle tanımlanır:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('use App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\nreturn function (RoutingConfigurator $routes): void {\n    $routes->add(\'blog_show\', \'/blog/{slug}\')\n        ->controller([BlogController::class, \'show\'])\n    ;\n};')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return function (RoutingConfigurator $routes): void {
$routes->add('blog_show', '/blog/{slug}')
->controller([BlogController::class, 'show'])
;
};</code></pre>

  </div>
</div>

Değişken kısmın adı ({slug} örneğinde) PHP'de bir değişken olarak oluşturulur ve route içeriği controller'a aktarılır. Bir kullanıcı /blog/ilk-yazi adresine giderse, Symfony BlogController içindeki show() metodunu çalıştırır ve $slug = 'ilk-yazi' olarak parametre gönderir.

Route'lar istediğiniz kadar parametre tanımlayabilir, ancak her parametre bir route'ta yalnızca bir kez kullanılabilir (ör: /blog/posts-about-{category}/page/{pageNumber}).

## Parametre Doğrulama

Diyelim ki uygulamanızda blog_show route'u (URL: /blog/{slug}) ve blog_list route'u (URL: /blog/{page}) var. Route parametreleri her değeri kabul ettiği için, ikisini ayırt etmenin bir yolu yok.

Kullanıcı /blog/ilk-yazi adresini isterse, iki route da eşleşir ve Symfony ilk tanımlanan route'u kullanır. Bunu düzeltmek için, {page} parametresine requirements seçeneği ile doğrulama ekleyin:

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('use App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\n\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->add(\'blog_list\', \'/blog/{page}\')\n        ->controller([BlogController::class, \'list\'])\n        ->requirements([\'page\' => \'\\d+\'])\n    ;\n\n    $routes->add(\'blog_show\', \'/blog/{slug}\')\n        ->controller([BlogController::class, \'show\'])\n    ;\n    // ...\n};')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
$routes->add('blog_list', '/blog/{page}')
->controller([BlogController::class, 'list'])
->requirements(['page' => '\d+'])
;

    $routes->add('blog_show', '/blog/{slug}')
        ->controller([BlogController::class, 'show'])
    ;
    // ...

};</code></pre>

  </div>
</div>

requirements seçeneği, route parametrelerinin eşleşmesi için gereken PHP regex'lerini tanımlar. Bu örnekte \d+ herhangi uzunlukta bir rakamı eşleştirir. Artık:

<table>
    <thead>
        <tr>
            <th>URL</th>
            <th>Route</th>
            <th>Parametre</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>/blog/2</td>
            <td>blog_list</td>
            <td>$page = 2</td>
        </tr>
        <tr>
            <td>/blog/ilk-yazi</td>
            <td>blog_show</td>
            <td>$slug = ilk-yazi</td>
        </tr>
    </tbody>
</table>

<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
  <span style="font-size:24px; margin-right:12px;">💡</span>
  <span style="color:#222; font-size:16px;">Requirement enum'u, rakamlar, tarihler ve UUID'ler gibi sık kullanılan regular-expression sabitlerini içerir ve route parametre gereksinimlerinde kullanılabilir.</span>
</div>

<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
  <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
    <div class="terminal-controls">
      <span>●</span>
      <span>●</span>
      <span>●</span>
    </div>
    <div class="terminal-copy js-activate-clipboard">
      <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('// config/routes.php\nuse App\\Controller\\BlogController;\nuse Symfony\\Component\\Routing\\Loader\\Configurator\\RoutingConfigurator;\nuse Symfony\\Component\\Routing\\Requirement\\Requirement;\n\nreturn static function (RoutingConfigurator $routes): void {\n    $routes->add(\'blog_list\', \'/blog/{page}\')\n        ->controller([BlogController::class, \'list\'])\n        ->requirements([\'page\' => Requirement::DIGITS])\n    ;\n    // ...\n};')">📋</span>
      <span class="js-copy-button-text"></span>
    </div>
  </div>
  <div class="js-copy-clipboard-target">
    <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">// config/routes.php
use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;
use Symfony\Component\Routing\Requirement\Requirement;

return static function (RoutingConfigurator $routes): void {
$routes->add('blog_list', '/blog/{page}')
->controller([BlogController::class, 'list'])
->requirements(['page' => Requirement::DIGITS])
;
// ...
};</code></pre>

  </div>
</div>

<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
  <span style="font-size:24px; margin-right:12px;">💡</span>
  <span style="color:#222; font-size:16px;">Route gereksinimleri (ve route yolları) yapılandırma parametreleri içerebilir. Bu, karmaşık regular expression'ları bir kez tanımlayıp birden fazla route'ta tekrar kullanmak için faydalıdır.</span>
</div>

<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
  <span style="font-size:24px; margin-right:12px;">💡</span>
  <span style="color:#222; font-size:16px;">Parametreler ayrıca PCRE Unicode özelliklerini de destekler. Bunlar, herhangi bir dilde büyük harf karakterleri için \p{Lu}, Yunanca karakterler için \p{Greek} gibi generic karakter tiplerini eşleştiren kaçış dizileridir.</span>
</div>
## Parametre Gereksinimlerini Satır İçi Tanımlama

İsterseniz, gereksinimleri her parametrede satır içi olarak {parametre_adı<gereksinim>} şeklinde tanımlayabilirsiniz. Bu özellik, yapılandırmayı daha kısa hale getirir; ancak gereksinimler karmaşıksa route okunabilirliğini azaltabilir:

```php
// config/routes.php
use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('blog_list', '/blog/{page<\d+>}')
        ->controller([BlogController::class, 'list'])
    ;
    // ...
};
```

## Opsiyonel Parametreler

Önceki örnekte, blog_list route'unun URL'si /blog/{page} şeklindedir. Kullanıcılar /blog/1 adresini ziyaret ederse eşleşir; ancak /blog adresini ziyaret ederlerse eşleşmez. Bir route'a parametre eklediğinizde, bu parametrenin bir değeri olmalıdır.

Kullanıcı /blog adresini ziyaret ettiğinde blog_list route'unun tekrar eşleşmesini istiyorsanız, {page} parametresi için varsayılan bir değer ekleyebilirsiniz. Attribute kullanırken varsayılan değerler controller metodunun argümanlarında tanımlanır. Diğer yapılandırma formatlarında ise defaults seçeneği ile tanımlanır:

```php
// config/routes.php
use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('blog_list', '/blog/{page}')
        ->controller([BlogController::class, 'list'])
        ->defaults(['page' => 1])
        ->requirements(['page' => '\d+'])
    ;
};
```

Artık kullanıcı /blog adresini ziyaret ettiğinde blog_list route'u eşleşir ve $page parametresi varsayılan olarak 1 değerini alır.


<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">💡</span>
    <span style="color:#222; font-size:16px;">Varsayılan değer, gereksinim ile eşleşmek zorunda değildir.</span>
</div>

<div style="background:#f7b955; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">⚠️</span>
    <span style="color:#222; font-size:16px;">
        Birden fazla opsiyonel parametre tanımlayabilirsiniz (ör. <code>/blog/{slug}/{page}</code>), ancak opsiyonel bir parametreden sonra gelen tüm parametreler de opsiyonel olmalıdır. Örneğin, <code>/{page}/blog</code> geçerli bir yoldur ve <code>page</code> her zaman gereklidir (<code>/blog</code> bu route ile eşleşmez).
    </span>
</div>



Bir parametreye varsayılan değer eklemek için, parametre adından sonra `?default_value` ekleyebilirsiniz. Örneğin, `/blog/{page?1}` ile `page` parametresinin varsayılan değeri `1` olur. Gereksinim ve varsayılan değeri birleştirmek için `{page<\d+>?1}` şeklinde yazabilirsiniz:

```php
// config/routes.php
use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('blog_list', '/blog/{page<\d+>?1}')
        ->controller([BlogController::class, 'list'])
    ;
};
```
<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">💡</span>
    <span style="color:#222; font-size:16px;">
        Bir parametreye <code>null</code> varsayılan değer vermek için, <code>?</code> karakterinden sonra bir değer belirtmeyin (örneğin, <code>/blog/{page?}</code>). Bu durumda, ilgili controller argümanının tipini nullable olarak tanımlamalısınız (örneğin, <code>?int $page</code>).
    </span>
</div>

##  Route Önceliği (Priority Parameter)

Symfony, route'ları tanımlandıkları sırayla değerlendirir. Bir route'un yolu birden fazla pattern ile eşleşiyorsa, diğer route'ların eşleşmesini engelleyebilir. YAML ve XML dosyalarında route tanımlarını yukarı veya aşağı taşıyarak önceliği kontrol edebilirsiniz. PHP attribute ile tanımlanan route'larda ise, önceliği kontrol etmek için `priority` parametresini kullanabilirsiniz:

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class BlogController extends AbstractController
{
    /**
     * Bu route daha genel bir pattern ile tanımlanmıştır ve önce gelir.
     */
    #[Route('/blog/{slug}', name: 'blog_show')]
    public function show(string $slug): Response
    {
        // ...
    }

    /**
     * Bu route, varsayılan öncelik ile eşleşemezdi; daha yüksek bir priority ile tanımlanmalıdır.
     */
    #[Route('/blog/list', name: 'blog_list', priority: 2)]
    public function list(): Response
    {
        // ...
    }
}
```

`priority` değeri ne kadar yüksek olursa, route o kadar önce değerlendirilir. Varsayılan değer `0`'dır. Bu sayede, daha spesifik route'ların genel pattern'lerden önce eşleşmesini sağlayabilirsiniz.

Priority parametresi bir tamsayı değer bekler. Daha yüksek priority değerine sahip route'lar, daha düşük olanlardan önce değerlendirilir. Eğer priority tanımlanmazsa, varsayılan değer <b style="color:red">0</b>'dır.
## Parametre Dönüştürme (Parameter Conversion)

Bazı durumlarda, bir route parametresinin (örneğin, kullanıcı ID'si gibi bir integer) doğrudan controller metodunda bir nesneye dönüştürülmesi gerekebilir. Symfony'de bu özelliğe "param converter" denir.

Önceki route yapılandırmasını koruyarak, controller metodunun argümanlarını değiştirelim. Artık string $slug yerine BlogPost $post parametresi kullanıyoruz:

```php
// src/Controller/BlogController.php
namespace App\Controller;

use App\Entity\BlogPost;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class BlogController extends AbstractController
{
    // ...

    #[Route('/blog/{slug:post}', name: 'blog_show')]
    public function show(BlogPost $post): Response
    {
        // $post, route parametresindeki slug ile eşleşen BlogPost nesnesidir

        // ...
    }
}
```

Controller argümanında nesne tipinde bir type-hint (örneğin BlogPost) varsa, param converter otomatik olarak ilgili nesneyi veritabanından bulur ve controller'a iletir. Eğer nesne bulunamazsa Symfony otomatik olarak 404 döndürür.

Burada `{slug:post}` sözdizimi, route parametresi olan slug'ı controller argümanı olan $post ile eşler ve param converter'ın veritabanından BlogPost nesnesini slug ile bulmasını sağlar.

> **Symfony 7.1 ile gelen özellik:** Route parametre eşleme ({slug:post}) Symfony 7.1 sürümünde eklenmiştir.

### Birden Fazla Nesne Eşleme

Birden fazla entity'yi route parametrelerinden eşlemek istediğinizde, parametre adlarında çakışma olmamalıdır. Örneğin, aşağıdaki tanım geçersizdir çünkü iki kez name parametresi kullanılmıştır:

```php
#[Route('/search-book/{name:author}/{name:category}')]
```

Bunun yerine, parametre adlarını benzersiz yapmalısınız:

```php
#[Route('/search-book/{authorName:author.name}/{categoryName:category.name}')]
```

Bu şekilde, route parametreleri (authorName ve categoryName) benzersiz olur ve param converter her birini doğru entity ile eşler.

> **Symfony 7.3 ile gelen özellik:** Bu gelişmiş parametre eşleme ({authorName:author.name}) Symfony 7.3 sürümünde eklenmiştir.

Daha gelişmiş eşlemeler için #[MapEntity] attribute'u kullanılabilir. Detaylı özelleştirme için Doctrine param converter dokümantasyonuna göz atabilirsiniz.

## Backed Enum Parametreleri

PHP'deki backed enum'ları route parametresi olarak kullanabilirsiniz. Symfony, bu parametreleri otomatik olarak scalar değerlerine dönüştürür:

```php
// src/Controller/OrderController.php
namespace App\Controller;

use App\Enum\OrderStatusEnum;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class OrderController extends AbstractController
{
    #[Route('/orders/list/{status}', name: 'list_orders_by_status')]
    public function list(OrderStatusEnum $status = OrderStatusEnum::Paid): Response
    {
        // ...
    }
}
```

## Özel Parametreler

Symfony, route'larda aşağıdaki özel parametreleri kullanmanıza izin verir:

- **_controller**: Eşleşen route için çalışacak controller ve aksiyonu belirtir.
- **_format**: İsteğin formatını belirler (ör. json formatı Content-Type: application/json olarak ayarlanır).
- **_fragment**: URL'nin sonundaki # ile başlayan fragment bilgisini ayarlar.
- **_locale**: İsteğin dilini belirler.

Bu parametreleri hem tekil route'larda hem de route importlarında kullanabilirsiniz. Symfony, bu özel parametreler için aynı isimde (başındaki alt çizgi olmadan) kolay tanımlama metodları sunar:

```php
// config/routes.php
namespace Symfony\Component\Routing\Loader\Configurator;

use App\Controller\ArticleController;

return static function (RoutingConfigurator $routes): void {
    $routes->add('article_show', '/articles/{_locale}/search.{_format}')
        ->controller([ArticleController::class, 'search'])
        ->locale('en')
        ->format('html')
        ->requirements([
            '_locale' => 'en|fr',
            '_format' => 'html|xml',
        ])
    ;
};
```

## Ekstra Parametreler

Route'un defaults seçeneğinde, route tanımında yer almayan ekstra parametreler belirtebilirsiniz. Bu parametreler controller'a ekstra argüman olarak iletilir:

```php
// config/routes.php
use App\Controller\BlogController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('blog_index', '/blog/{page}')
        ->controller([BlogController::class, 'index'])
        ->defaults([
            'page'  => 1,
            'title' => 'Hello world!',
        ])
    ;
};
```

## Route Parametrelerinde Slash Karakteri Kullanmak

Route parametreleri, `/` (slash) karakteri hariç herhangi bir değeri içerebilir; çünkü `/` karakteri URL'nin farklı bölümlerini ayırmak için kullanılır. Örneğin, `/share/{token}` route'unda token değeri `/` içerirse, bu route eşleşmez.

Bunu çözmek için, parametre gereksinimini daha esnek hale getirebilirsiniz:

```php
// config/routes.php
use App\Controller\DefaultController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('share', '/share/{token}')
        ->controller([DefaultController::class, 'share'])
        ->requirements([
            'token' => '.+',
        ])
    ;
};
```

<div style="background:#f6f8fa; border-radius:8px; padding:16px; margin-bottom:16px;">
    <div style="display:flex; align-items:flex-start; margin-bottom:12px;">
        <span style="font-size:22px; margin-right:12px;">📝</span>
        <div style="color:red">
            Eğer bir route birden fazla parametre içeriyorsa ve hepsine esnek bir regular expression (ör. <code>.+</code>) uygularsanız, beklenmedik sonuçlar ortaya çıkabilir. Örneğin, route tanımı <code>/share/{path}/{token}</code> şeklindeyse ve hem <code>path</code> hem de <code>token</code> parametreleri <code>/</code> karakterini kabul ederse, <code>token</code> yalnızca son bölümü alır, kalan kısım ise <code>path</code> tarafından eşleşir.
        </div>
    </div>
    <div style="display:flex; align-items:flex-start;">
        <span style="font-size:22px; margin-right:12px;">📝</span>
        <div style="color:red">
            Ayrıca, route özel <code>{_format}</code> parametresini içeriyorsa, parametreler için <code>.+</code> gereksinimini kullanmamalısınız. Örneğin, <code>/share/{token}.{_format}</code> pattern'inde <code>{token}</code> herhangi bir karakteri kabul ederse, <code>/share/foo/bar.json</code> URL'sinde <code>token = foo/bar.json</code> olur ve <code>_format</code> parametresi boş kalır. Bunu önlemek için, <code>.+</code> yerine <code>[^.]+</code> kullanarak sadece nokta hariç tüm karakterleri kabul edebilirsiniz.
        </div>
    </div>
</div>

## Route Alias (Route Takma Adı)

YAML, XML ve PHP yapılandırma formatları, sahip olmadığınız bir route için alias (takma ad) tanımlamanın tek yoludur. PHP attribute ile tanımlanan route'larda doğrudan alias ekleyemezsiniz.

Route alias, bir route'a birden fazla isim vermenizi sağlar ve özellikle route adını değiştirdiğinizde geriye dönük uyumluluk için kullanışlıdır. Örneğin, product_show adlı bir route'unuz varsa ve aynı davranışı product_details adıyla da sunmak istiyorsanız, route'u tekrar tanımlamak yerine bir alias ekleyebilirsiniz:

```php
// config/routes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('product_show', '/product/{id}')
        ->controller('App\Controller\ProductController::show');
    // İkinci argüman, yukarıda tanımlanan route adını belirtir
    $routes->alias('product_details', 'product_show');
};
```

Bu örnekte, hem product_show hem de product_details route adları kullanılabilir ve aynı controller aksiyonu çalışır.

> **Symfony 7.3 ile gelen özellik:** PHP attribute ile tanımlanan route'larda alias desteği Symfony 7.3 sürümünde eklenmiştir.

Alias ve orijinal route aynı dosyada veya farklı dosya/formatlarda tanımlanabilir. Alias tanımlayarak, URL üretiminde kendi route adınızı kullanabilir ve üçüncü parti bundle tarafından tanımlanan bir route'u hedefleyebilirsiniz.


<div style="background:white; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">📝</span>
    <span style="color:#222; font-size:16px;">
        YAML, XML ve PHP yapılandırma formatları, sahip olmadığınız bir route için alias (takma ad) tanımlamanın tek yoludur. PHP attribute ile tanımlanan route'larda doğrudan alias ekleyemezsiniz.<br><br>
        Bu sayede, örneğin URL üretiminde kendi route adınızı kullanabilir ve üçüncü parti bir bundle tarafından tanımlanan route'u hedefleyebilirsiniz. Alias ve orijinal route aynı dosyada veya farklı dosya/formatlarda tanımlanabilir.
    </span>
</div>


## Route Alias'larını Kullanımdan Kaldırmak (Deprecate Etmek)

Route alias'ları, yeniden adlandırılan route'lar için geriye dönük uyumluluk sağlar. Bir route'u kullanımdan kaldırmak (deprecate etmek) için alias'ı "tersine" çevirmeniz gerekir: Eski route adı (örneğin `product_show`) artık bir alias olur ve yeni route'a (`product_details`) yönlendirilir.

Aşağıdaki örnekte, `product_details` ana route olarak tanımlanır ve `product_show` alias'ı ona yönlendirilir. Alias'ı kullanımdan kaldırmak için `deprecate()` fonksiyonu eklenir:

```php
// config/routes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('product_details', '/product/{id}')
        ->controller('App\Controller\ProductController::show');

    // Eski route adı artık alias olarak tanımlanıyor ve deprecate ediliyor
    $routes->alias('product_show', 'product_details')
        // Varsayılan deprecation mesajı
        ->deprecate('acme/package', '1.2', '')
        // veya özel bir mesaj ile
        ->deprecate(
            'acme/package',
            '1.2',
            'The "%alias_id%" route alias is deprecated. Please use "product_details" instead.'
        )
    ;
};
```

Bu yapılandırmada, her `product_show` alias kullanıldığında bir deprecation uyarısı tetiklenir. Mesajda `%alias_id%` placeholder'ı otomatik olarak alias adı ile değiştirilir. Kendi mesajınızı tanımlarken en az bir `%alias_id%` kullanmalısınız.

Bu yöntemle, eski route adını kullanan uygulamalar uyarılır ve yeni route'a geçiş teşvik edilir.

## Route Grupları ve Prefix Kullanımı

Bir grup route'un ortak ayarları paylaşması (örneğin, blog ile ilgili tüm route'ların `/blog` ile başlaması) yaygındır. Symfony, route yapılandırmasını paylaşmak için bu amaçla bir özellik sunar.

Attribute ile route tanımlarken, ortak yapılandırmayı controller sınıfının #[Route] attribute'una ekleyebilirsiniz. Diğer routing formatlarında ise, route'ları import ederken ortak ayarları options ile tanımlayabilirsiniz.

```php
// config/routes/attributes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->import(
            '../../src/Controller/',
            'attribute',
            false,
            // Dördüncü argüman ile bazı dosya veya alt dizinleri hariç tutabilirsiniz
            // (değer bir string veya PHP glob pattern dizisi olmalı)
            '../../src/Controller/{Debug*Controller.php}'
        )
        // Tüm import edilen route URL'lerinin başına eklenir
        ->prefix('/blog')

        // Boş URL'li bir route "/blog/" olur
        // İkinci argüman olarak FALSE verirseniz "/blog" olur
        // ->prefix('/blog', false)

        // Tüm import edilen route adlarının başına eklenir
        ->namePrefix('blog_')

        // Tüm import edilen route'lara ek gereksinimler eklenir
        ->requirements(['_locale' => 'en|es|fr'])
    ;
};
```

<div style="background:#f7b955; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">⚠️</span>
    <span style="color:#222; font-size:16px;">
        <code>exclude</code> seçeneği yalnızca <code>resource</code> değeri bir glob string ise çalışır. Eğer normal bir string kullanırsanız (ör. <code>'../src/Controller'</code>), <code>exclude</code> değeri göz ardı edilir.
    </span>
</div>

Bu örnekte, index() aksiyonunun route'u `blog_index` adını ve `/blog/{_locale}` URL'sini alır. show() aksiyonunun route'u ise `blog_show` adını ve `/blog/{_locale}/posts/{slug}` URL'sini alır. Her iki route da `_locale` parametresinin belirtilen regular expression ile eşleşmesini doğrular.

Eğer prefixlenen route'lar boş bir path tanımlarsa, Symfony otomatik olarak sonuna bir slash ekler. Örneğin, boş bir path ve `/blog` prefix ile `/blog/` URL'si oluşur. Bu davranışı engellemek için `trailing_slash_on_root` seçeneğini false yapabilirsiniz (bu seçenek PHP attribute ile kullanılamaz):

```php
// config/routes/attributes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->import('../../src/Controller/', 'attribute')
        // İkinci argüman $trailingSlashOnRoot seçeneğidir
        ->prefix('/blog', false)

        // ...
    ;
};
```

> Symfony, farklı kaynaklardan route import edebilir ve kendi route loader'ınızı da oluşturabilirsiniz.

## Route Adı ve Parametrelerini Alma

Symfony'de, bir isteğin eşleştiği route'un adını ve parametrelerini almak için Request nesnesinin attributes özelliğini kullanabilirsiniz. Controller içinde bu bilgilere aşağıdaki şekilde erişebilirsiniz:

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

class BlogController extends AbstractController
{
    #[Route('/blog', name: 'blog_list')]
    public function list(Request $request): Response
    {
        $routeName = $request->attributes->get('_route');
        $routeParameters = $request->attributes->get('_route_params');

        // Tüm attribute'ları almak için:
        $allAttributes = $request->attributes->all();

        // ...
    }
}
```

Servislerde bu bilgilere erişmek için `RequestStack` servisini enjekte edebilirsiniz. Twig şablonlarında ise `app.current_route` ve `app.current_route_parameters` global değişkenlerini kullanabilirsiniz.

---

## Özel Route'lar

Symfony, bazı özel controller'lar ile doğrudan route yapılandırmasından şablon render etme veya başka bir route/URL'ye yönlendirme işlemlerini kolaylaştırır.

### Route'tan Şablon Render Etmek

Bir route'tan doğrudan şablon render etmek için Symfony'nin template controller özelliğini kullanabilirsiniz. Detaylar için Symfony template dokümantasyonuna bakınız.

### Route'tan URL veya Route'a Yönlendirme

Başka bir route veya URL'ye yönlendirmek için `RedirectController` kullanılır:

```php
// config/routes.php
use App\Controller\DefaultController;
use Symfony\Bundle\FrameworkBundle\Controller\RedirectController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('doc_shortcut', '/doc')
        ->controller(RedirectController::class)
         ->defaults([
            'route' => 'doc_page',
            // isteğe bağlı olarak, route'a iletilecek bazı argümanlar tanımlayabilirsiniz
            'page' => 'index',
            'version' => 'current',
            // yönlendirmeler varsayılan olarak geçicidir (kod 302), ancak kalıcı yapabilirsiniz (kod 301)
            'permanent' => true,
            // yönlendirme sırasında orijinal query string parametrelerini korumak için bunu ekleyin
            'keepQueryParams' => true,
            // yönlendirme sırasında HTTP metodunu korumak için bunu ekleyin. Yönlendirme durumu değişir:
            // * geçici yönlendirmelerde, 302 yerine 307 durum kodu kullanılır
            // * kalıcı yönlendirmelerde, 301 yerine 308 durum kodu kullanılır
            'keepRequestMethod' => true,
        ])
    ;

    $routes->add('legacy_doc', '/legacy/doc')
        ->controller(RedirectController::class)
         ->defaults([
            // bu değer mutlak bir yol veya mutlak bir URL olabilir
            'path' => 'https://legacy.example.com/doc',
            // yönlendirmeler varsayılan olarak geçicidir (kod 302), ancak kalıcı yapabilirsiniz (kod 301)
            'permanent' => true,
        ])
    ;
};
```



<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">💡</span>
    <span style="color:#222; font-size:16px;">
        Symfony ayrıca <a href="https://symfony.com/doc/current/controller.html#redirecting" target="_blank" style="color:#1677ff; text-decoration:underline;">controller içinde yönlendirme</a> işlemleri için bazı yardımcılar sağlar.
    </span>
</div>


## Sonunda Slash Olan URL'leri Yönlendirmek

Tarihsel olarak, URL'lerde dizinler için sonunda slash (`/`) kullanılır (ör. `https://example.com/foo/`), dosyalar için ise kullanılmaz (`https://example.com/foo`). Modern uygulamalarda ise genellikle her iki URL aynı içerik olarak kabul edilir ve biri diğerine yönlendirilir.

Symfony, GET ve HEAD isteklerinde sonunda slash olan ve olmayan URL'ler arasında otomatik olarak 301 yönlendirme yapar:

| Route URL | İstek /foo | İstek /foo/ |
|-----------|------------|-------------|
| /foo      | Eşleşir (200) | /foo adresine 301 yönlendirme |
| /foo/     | /foo/ adresine 301 yönlendirme | Eşleşir (200) |

## Alt Alan Adı (Sub-Domain) ile Routing

Route'lar, gelen isteğin host (alan adı) bilgisini kontrol etmek için `host` seçeneği ile yapılandırılabilir. Böylece aynı path için farklı alan adlarına özel controller tanımlayabilirsiniz:

```php
// config/routes.php
use App\Controller\MainController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('mobile_homepage', '/')
        ->controller([MainController::class, 'mobileHomepage'])
        ->host('m.example.com')
    ;
    $routes->add('homepage', '/')
        ->controller([MainController::class, 'homepage'])
    ;
};
```
Yukarıdaki örnekte, subdomain parametresi için varsayılan bir değer tanımlanmıştır. Böylece, bu route'ları kullanarak URL üretirken her seferinde subdomain değeri belirtmek zorunda kalmazsınız; varsayılan olarak 'm' değeri kullanılır.

<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">💡</span>
    <span style="color:#222; font-size:16px;">
        Route'ları import ederken host seçeneğini ayarlayarak, tüm import edilen route'ların belirli bir alan adı (host) ile eşleşmesini sağlayabilirsiniz.
    </span>
</div>

```php


/* Alt alan adı (sub-domain) ile routing kullanırken, fonksiyonel testlerde veya otomatik testlerde route'ların doğru eşleşmesi için HTTP_HOST başlığını ayarlamanız gerekir; aksi halde route'lar eşleşmez: */
$crawler = $client->request(
    'GET',
    '/',
    [],
    [],
    ['HTTP_HOST' => 'm.example.com']
    // veya değeri bir yapılandırma parametresinden almak için:
    // ['HTTP_HOST' => 'm.'.$client->getContainer()->getParameter('domain')]
);


```

<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">💡</span>
    <span style="color:#222; font-size:16px;">
    Host parametresinde satır içi varsayılan değer ve gereksinim tanımlayabilirsiniz: `{subdomain<m|mobile>?m}.example.com` şeklinde yazdığınızda, `subdomain` parametresi sadece `m` veya `mobile` değerlerini kabul eder ve varsayılan olarak `m` kullanılır.
    </span>
</div>


## Yerelleştirilmiş Route'lar (i18n)

Uygulamanız birden fazla dile sahipse, her locale için farklı bir URL tanımlayabilirsiniz:

```php
// config/routes.php
use App\Controller\CompanyController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('about_us', [
        'en' => '/about-us',
        'nl' => '/over-ons',
    ])
        ->controller([CompanyController::class, 'about'])
    ;
};
```

<div style="display:flex; align-items:center; background:#f6f8fa; border-radius:8px; padding:12px; margin-bottom:16px;">
    <span style="font-size:22px; margin-right:12px;">📝</span>
    <span style="color:#222; font-size:16px;">
        PHP attribute ile yerelleştirilmiş route tanımlarken, <code>path</code> adlandırılmış parametresini kullanarak path dizisini belirtmelisiniz.
    </span>
</div>

Yerelleştirilmiş bir route eşleştiğinde, Symfony isteğin tamamında aynı locale bilgisini otomatik olarak kullanır.
<div style="background:#19c37d; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">💡</span>
    <span style="color:#222; font-size:16px;">
        Uygulama tam "dil + ülke" yerelleri (örn. <code>fr_FR</code>, <code>fr_BE</code>) kullanıyorsa ve ilgili yerellerdeki URL'ler aynıysa, route'larda yalnızca dil kısmı (örn. <code>fr</code>) kullanılabilir. Böylece aynı URL'lerin tekrar edilmesi önlenir.
    </span>
</div>
Uluslararasılaştırılmış (i18n) uygulamalarda yaygın bir gereksinim, tüm route'ların başına locale (dil) prefix'i eklemektir. Bunu, her locale için farklı bir prefix tanımlayarak (varsayılan locale için boş prefix ayarlayarak) gerçekleştirebilirsiniz:

```php
// config/routes/attributes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->import('../../src/Controller/', 'attribute')
        ->prefix([
            // İngilizce (varsayılan locale) için prefix eklenmez
            'en' => '',
            'nl' => '/nl',
        ])
    ;
};
```

<div style="background:#f6f8fa; border-radius:8px; padding:16px; margin-bottom:16px;">
    <div style="display:flex; align-items:flex-start;">
        <span style="font-size:22px; margin-right:12px;">📝</span>
        <div style="color:red">
            Eğer içe aktarılan bir route kendi tanımında özel <code>_locale</code> parametresini içeriyorsa, Symfony sadece o locale için import eder ve diğer yapılandırılmış locale prefix'leri için import etmez.
            <br><br>
            Örneğin, bir route tanımında <code>locale: 'en'</code> varsa ve <code>en</code> (prefix: boş) ile <code>nl</code> (prefix: <code>/nl</code>) locale'leriyle import ediliyorsa, bu route sadece <code>en</code> locale'inde kullanılabilir olur, <code>nl</code> locale'inde olmaz.
        </div>
    </div>
</div>

### Locale'a Göre Farklı Domain Kullanmak

Sık karşılaşılan bir gereksinim, uygulamanın farklı dillerde farklı alan adlarında (domain) yayınlanmasıdır. Her locale için farklı bir host tanımlayarak bunu sağlayabilirsiniz:

```php
// config/routes/attributes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->import('../../src/Controller/', 'attribute')
        ->host([
            'en' => 'www.example.com',
            'nl' => 'www.example.nl',
        ])
    ;
};
```

Bu yapılandırma ile, İngilizce locale için `www.example.com`, Hollandaca locale için ise `www.example.nl` alan adı kullanılır.

---

## Stateless Route'lar

Bazı durumlarda, HTTP yanıtının önbelleğe alınabilmesi için oturum (session) kullanılmaması gerekir. Symfony'de bir route'u "stateless" olarak işaretleyerek, eşleşen istekte oturum başlatılmasını engelleyebilirsiniz:

```php
// config/routes.php
use App\Controller\MainController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('homepage', '/')
        ->controller([MainController::class, 'homepage'])
        ->stateless()
    ;
};
```

Eğer oturum kullanılırsa, uygulama `kernel.debug` parametresine göre davranır:

- `enabled`: `UnexpectedSessionUsageException` hatası fırlatılır.
- `disabled`: Uyarı loglanır.

Bu sayede, beklenmeyen oturum kullanımlarını tespit edebilir ve önbellek davranışını iyileştirebilirsiniz.

Daha fazla bilgi için [HTTP Cache](https://symfony.com/doc/current/http_cache.html) dokümantasyonuna göz atabilirsiniz.

## URL Oluşturma (Generating URLs)

Routing sistemi çift yönlü çalışır:

- URL'leri controller'lara eşler (önceki bölümlerde açıklandığı gibi)
- Bir route için URL üretir

Route'lardan URL üretmek, HTML şablonlarınızda `<a href="...">` değerlerini elle yazmanıza gerek bırakmaz. Ayrıca, bir route'un URL'si değişirse, sadece route yapılandırmasını güncellemeniz yeterlidir; tüm linkler otomatik olarak güncellenir.

Bir URL üretmek için, route'un adını (ör. `blog_show`) ve route tarafından tanımlanan parametrelerin değerlerini (ör. `slug = my-blog-post`) belirtmeniz gerekir.

Bu nedenle, her route'un uygulamada benzersiz bir dahili adı olmalıdır. Eğer `name` seçeneği ile route adı açıkça belirtilmezse, Symfony otomatik olarak controller ve aksiyona göre bir ad oluşturur.

Symfony, hedef sınıfta `__invoke()` metodu varsa ve sadece bir route eklenmişse FQCN'e göre route alias'ı tanımlar. Ayrıca, her metot yalnızca bir route tanımlıyorsa otomatik olarak bir alias ekler. Örneğin:

```php
// src/Controller/MainController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Routing\Attribute\Route;

final class MainController extends AbstractController
{
    #[Route('/', name: 'homepage')]
    public function homepage(): Response
    {
        // ...
    }
}
```

Symfony, bu örnekte `App\Controller\MainController::homepage` adlı bir route alias'ı ekler.

### Controller'da URL Üretmek

Controller'ınız `AbstractController`'dan türemişse, `generateUrl()` yardımcı metodunu kullanabilirsiniz:

```php
// src/Controller/BlogController.php
namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

class BlogController extends AbstractController
{
    #[Route('/blog', name: 'blog_list')]
    public function list(): Response
    {
        // Route argümanı olmadan URL üretmek
        $signUpPage = $this->generateUrl('sign_up');

        // Route argümanları ile URL üretmek
        $userProfilePage = $this->generateUrl('user_profile', [
            'username' => $user->getUserIdentifier(),
        ]);

        // Varsayılan olarak üretilen URL'ler "absolute path" olur.
        // Farklı bir URL tipi üretmek için üçüncü argümanı kullanabilirsiniz (ör. tam URL)
        $signUpPage = $this->generateUrl('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

        // Route yerelleştirildiyse, Symfony varsayılan olarak mevcut isteğin locale'ini kullanır.
        // Farklı bir '_locale' değeri ile URL üretmek için parametre ekleyin
        $signUpPageInDutch = $this->generateUrl('sign_up', ['_locale' => 'nl']);

        // ...
    }
}
```
f you pass to the generateUrl() method some parameters that are not part of the route definition, they are included in the generated URL as a query string:


<div style="background:yellow;color:red; border-radius:8px; padding:16px; margin-bottom:16px;">
    Eğer <code>generateUrl()</code> metoduna, route tanımında yer almayan bazı parametreler verirseniz, bu parametreler üretilen URL'de query string olarak eklenir:
    <div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-top:16px;">
        <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
            <div class="terminal-controls">
                <span>●</span>
                <span>●</span>
                <span>●</span>
            </div>
            <div class="terminal-copy js-activate-clipboard">
                <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('$this->generateUrl(\'blog\', [\'page\' => 2, \'category\' => \'Symfony\']);\n// \'blog\' route\'u sadece \'page\' parametresini tanımlar; üretilen URL:\n// /blog/2?category=Symfony')">📋</span>
                <span class="js-copy-button-text"></span>
            </div>
        </div>
        <div class="js-copy-clipboard-target">
            <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">$this->generateUrl('blog', ['page' => 2, 'category' => 'Symfony']);
// 'blog' route'u sadece 'page' parametresini tanımlar; üretilen URL:
// /blog/2?category=Symfony</code></pre>
        </div>
    </div>
</div>

<div style="background:#f7b955; border-radius:8px; padding:12px; margin-bottom:16px; display:flex; align-items:center;">
    <span style="font-size:24px; margin-right:12px;">⚠️</span>
    <span style="color:#222; font-size:16px;">
        Nesneler, route parametresi olarak kullanıldığında otomatik olarak string'e dönüştürülür; ancak ekstra parametre olarak kullanıldıklarında dönüştürülmezler. Yani, bir nesneyi (örneğin Uuid) ekstra parametre olarak ekliyorsanız, açıkça string'e dönüştürmelisiniz:
    </span>
</div>
<div class="terminal-wrapper bg-black-4 rounded-t" style="background:#222; border-radius:8px; margin-bottom:16px;">
    <div class="flex justify-between py-1 px-3" style="display:flex; justify-content:space-between; align-items:center; padding:8px 16px;">
        <div class="terminal-controls">
            <span>●</span>
            <span>●</span>
            <span>●</span>
        </div>
        <div class="terminal-copy js-activate-clipboard">
            <span class="fa fa-clipboard text-white" title="Copy Code" style="cursor:pointer; font-size:18px;" onclick="navigator.clipboard.writeText('$this->generateUrl(\'blog\', [\'uuid\' => (string) $entity->getUuid()]);')">📋</span>
            <span class="js-copy-button-text"></span>
        </div>
    </div>
    <div class="js-copy-clipboard-target">
        <pre class="notranslate" style="color:#fff; margin:0; padding:16px;"><code class="language-php">$this->generateUrl('blog', ['uuid' => (string) $entity->getUuid()]);</code></pre>
    </div>
</div>
```

Controller'ınız AbstractController'dan türemiyorsa, gerekli servisleri manuel olarak çekmeniz ve bir sonraki bölümdeki yönergeleri takip etmeniz gerekir.

## Generating URLs in Services / Servislerde URL'lerin Oluşturulması



Kendi servislerinizde URL oluşturmak için Symfony'nin `router` servisini inject ederek `generate()` metodunu kullanabilirsiniz. Servis otomatik bağlama (autowiring) kullanıyorsanız, sadece servis yapıcısına bir argüman ekleyip `UrlGeneratorInterface` sınıfıyla tip belirterek yeterlidir:

```php
// src/Service/SomeService.php
namespace App\Service;

use Symfony\Component\Routing\Generator\UrlGeneratorInterface;

class SomeService
{
    public function __construct(
        private UrlGeneratorInterface $urlGenerator,
    ) {
    }

    public function someMethod(): void
    {
        // ...

        // route argümanı olmadan bir URL oluştur
        $signUpPage = $this->urlGenerator->generate('sign_up');

        // route argümanlarıyla bir URL oluştur
        $userProfilePage = $this->urlGenerator->generate('user_profile', [
            'username' => $user->getUserIdentifier(),
        ]);

        // varsayılan olarak oluşturulan URL'ler "absolute path"tir.
        // Farklı türde URL oluşturmak için üçüncü bir opsiyonel argüman geç
        $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

        // route yerelleştirilmişse, Symfony varsayılan olarak mevcut isteğin dilini kullanır
        // dili açıkça belirtmek istiyorsan '_locale' parametresi geçir
        $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']);
    }
}
```

---

## Şablonlarda URL Oluşturulması

Symfony şablonlarında sayfalar arasında bağlantı oluşturma konusundaki ana makaleye bakın.

---

## JavaScript'te URL Oluşturulması

JavaScript kodunuz Twig şablonunda yer alıyorsa, `path()` ve `url()` Twig fonksiyonlarını kullanarak URL'leri oluşturabilir ve JavaScript değişkenlerinde saklayabilirsiniz. JavaScript'e uygun olmayan karakterleri kaçırmak için `escape('js')` filtresi gerekir:

```twig
<script>
    const route = "{{ path('blog_show', {slug: 'my-blog-post'})|escape('js') }}";
</script>
```

JavaScript kodu dinamik olarak çalışıyorsa veya saf JavaScript kullanıyorsanız, bu yöntem işe yaramaz. Bu durumda, `FOSJsRoutingBundle` kullanmayı düşünün.

---

## Generating URLs in Commands / Komutlarda URL Oluşturulması

Komutlarda URL oluşturma, servislerdeki ile aynı şekilde çalışır. Tek fark, komutlar HTTP bağlamında çalışmaz. Bu yüzden tam URL oluşturduğunuzda `http://localhost/` gibi varsayılan bir ana makine adı kullanılır.

Bu sorunu çözmek için, komutlar URL oluştururken kullanılacak "istek bağlamı"nı tanımlayan `default_uri` seçeneğini yapılandırın:

```php
// config/packages/routing.php
use Symfony\Config\FrameworkConfig;

return static function (FrameworkConfig $framework): void {
    $framework->router()->defaultUri('https://example.org/my/path/');
};
```

Artık komutlarda URL oluşturduğunuzda beklediğiniz sonuçları alırsınız:

```php
// src/Command/MyCommand.php
namespace App\Command;

use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
// ...

#[AsCommand(name: 'app:my-command')]
class MyCommand
{
    public function __construct(
        private UrlGeneratorInterface $urlGenerator,
    ) {
    }

    public function __invoke(SymfonyStyle $io): int
    {
        $signUpPage = $this->urlGenerator->generate('sign_up');

        $userProfilePage = $this->urlGenerator->generate('user_profile', [
            'username' => $user->getUserIdentifier(),
        ]);

        $signUpPage = $this->urlGenerator->generate('sign_up', [], UrlGeneratorInterface::ABSOLUTE_URL);

        $signUpPageInDutch = $this->urlGenerator->generate('sign_up', ['_locale' => 'nl']);
    }
}
```

Note: Varsayılan olarak, web varlıkları için oluşturulan URL'ler aynı `default_uri` değerini kullanır. Bunu değiştirmek için `asset.request_context.base_path` ve `asset.request_context.secure` container parametrelerini yapılandırabilirsiniz.

---

## Checking if a Route Exists / Bir Rota Var mı Kontrol Etmek

Dinamik uygulamalarda bir rota kullanmadan önce var olup olmadığını kontrol etmeniz gerekebilir. Bu durumda `getRouteCollection()` metodunu kullanmayın çünkü bu işlem yönlendirme önbelleğini yeniden oluşturur ve performansı düşürür.

Bunun yerine URL’yi oluşturmaya çalışın ve rota yoksa fırlatılan `RouteNotFoundException` hatasını yakalayın:

```php
use Symfony\Component\Routing\Exception\RouteNotFoundException;

try {
    $url = $this->router->generate($routeName, $routeParameters);
} catch (RouteNotFoundException $e) {
    // rota tanımlı değil...
}
```

---

### Forcing HTTPS on Generated URLs / Oluşturulan URL'lerde HTTPS Zorunlu Kılmak

Sunucunuz SSL'yi bir proxy arkasında sonlandırıyorsa, Symfony'yi bu tür bir proxy arkasında çalışacak şekilde yapılandırmalısınız.

Varsayılan olarak oluşturulan URL'ler mevcut isteğin HTTP şemasını kullanır. Konsol komutlarında HTTP isteği olmadığı için varsayılan olarak `http` kullanılır. Bunu her komutta `router.getContext()` ile veya küresel olarak aşağıdaki gibi yapılandırarak değiştirebilirsiniz:

```php
// config/services.php
$container->parameters()
    ->set('router.request_context.scheme', 'https')
    ->set('asset.request_context.secure', true);
```

Rotaların kendisinde HTTPS zorunluluğu tanımlamak için `schemes` seçeneğini kullanın:

```php
// config/routes.php
use App\Controller\SecurityController;
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->add('login', '/login')
        ->controller([SecurityController::class, 'login'])
        ->schemes(['https']);
};
```

Bu durumda `path()` Twig fonksiyonu, isteğin şeması HTTP ise tam bir URL oluşturur:

```twig
{{ path('login') }}
```

Birden fazla route'a HTTPS zorunluluğu getirmek istiyorsanız, import sırasında `schemes(['https'])` kullanabilirsiniz:

```php
// config/routes/attributes.php
use Symfony\Component\Routing\Loader\Configurator\RoutingConfigurator;

return static function (RoutingConfigurator $routes): void {
    $routes->import('../../src/Controller/', 'attribute')
        ->schemes(['https']);
};
```

Alternatif olarak `requires_channel` ayarıyla Güvenlik (Security) bileşeni üzerinden de HTTPS zorunluluğu getirilebilir.

---

### Signing URIs / URI İmzalama

İmzalı bir URI, URI içeriğine bağlı bir hash değeri içerir. Bu şekilde, URI’nin içeriği değiştirilmiş mi kontrol edilebilir. Symfony, URI’leri imzalamak için `UriSigner` servisini sağlar:

```php
// src/Service/SomeService.php
namespace App\Service;

use Symfony\Component\HttpFoundation\UriSigner;

class SomeService
{
    public function __construct(
        private UriSigner $uriSigner,
    ) {
    }

    public function someMethod(): void
    {
        $url = 'https://example.com/foo/bar?sort=desc';

        $signedUrl = $this->uriSigner->sign($url);

        $uriSignatureIsValid = $this->uriSigner->check($signedUrl);

        $uriSignatureIsValid = $this->uriSigner->checkRequest($request);
    }
}
```

Varsayılan olarak imzalı URI’ler zaman aşımına uğramaz, fakat bir sona erme tarihi tanımlayabilirsiniz:

```php
$signedUrl = $this->uriSigner->sign($url, new \DateTimeImmutable('2050-01-01'));

$signedUrl = $this->uriSigner->sign($url, new \DateInterval('PT10S'));

$signedUrl = $this->uriSigner->sign($url, 4070908800);
```

---

### İmzalı URI Geçersizse Nedenini Öğrenme

Symfony 7.3 ile gelen `verify()` metodu sayesinde geçersiz imzaların nedenini öğrenebilirsiniz:

```php
use Symfony\Component\HttpFoundation\Exception\ExpiredSignedUriException;
use Symfony\Component\HttpFoundation\Exception\UnsignedUriException;
use Symfony\Component\HttpFoundation\Exception\UnverifiedSignedUriException;

try {
    $uriSigner->verify($uri);
} catch (UnsignedUriException) {
    // URI imzalı değil
} catch (UnverifiedSignedUriException) {
    // URI imzalı ama imza geçersiz
} catch (ExpiredSignedUriException) {
    // URI imzalı ama süresi dolmuş
}
```

`Symfony Clock` yüklüyse, zaman hesaplamalarında otomatik olarak kullanılır. Bu da testlerde zamanı sahtelemek için kullanılabilir.

---

### ⚠️ Warning (⚠️ Uyarı)

Routing ile Çalışırken Yaygın Hatalar

**Hata:**

```
Controller "App\\Controller\\BlogController::show()" requires that you
provide a value for the "$slug" argument.
```

Sebep: Controller metodunda `$slug` argümanı var ama route tanımı içinde `{slug}` parametresi yok. `/blog/show/{slug}` olarak düzeltin ya da varsayılan değer atayın: `$slug = null`.

---

**Hata:**

```
Some mandatory parameters are missing ("slug") to generate a URL for route "blog_show".
```

Sebep: `blog_show` rotasına URL oluşturulurken gerekli `slug` parametresi verilmedi. Şöyle düzeltilir:

```php
$this->generateUrl('blog_show', ['slug' => 'slug-value']);
```

veya Twig içinde:

```twig
{{ path('blog_show', {slug: 'slug-value'}) }}
```
