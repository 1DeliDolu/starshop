WEBVTT

00:00:01.066 --> 00:00:03.736 align:middle
Tenemos una tabla parts,
¡y la estamos utilizando!

00:00:04.156 --> 00:00:08.766 align:middle
Pero ahora queremos clasificar los recambios por price
de forma descendente, porque si vamos a hacer upselling,

00:00:08.766 --> 00:00:11.526 align:middle
mejor empezar por los más caros, ¿no?

00:00:12.226 --> 00:00:16.396 align:middle
Es una tarea sencilla, pero vamos a hacerla más
emocionante elaborando una consulta personalizada.

00:00:16.916 --> 00:00:20.446 align:middle
Abre src/Repository/StarshipPartRepository.php.

00:00:20.446 --> 00:00:21.676 align:middle
¿Ves el método stubbed?

00:00:22.026 --> 00:00:26.326 align:middle
Cópialo y descoméntalo: este documento
PHP es muy útil y no queremos perderlo.

00:00:27.016 --> 00:00:33.066 align:middle
Elimina el último stub y
ponle findAllOrderedByPrice().

00:00:33.586 --> 00:00:38.036 align:middle
Elimina el argumento $value, no es
necesario: Construye una consulta simple:

00:00:38.296 --> 00:00:40.846 align:middle
Utilizaré sp como alias de StarshipPart.

00:00:41.356 --> 00:00:43.996 align:middle
Deshazte de andWhere() y
setParameter() que hay debajo.

00:00:44.746 --> 00:00:49.096 align:middle
Sin embargo, necesitamos el orderBy():
como orderBy('sp.price', 'DESC').

00:00:49.906 --> 00:00:53.866 align:middle
El setMaxResults() también puede desaparecer:
Consulta personalizada, ¡comprobado!

00:00:54.336 --> 00:00:56.866 align:middle
Copia el nombre del método
y dirígete a PartController.

00:00:57.526 --> 00:01:02.896 align:middle
Utilízalo en lugar de findAll(): Comprueba
las consultas de esta página: hay 9.

00:01:03.896 --> 00:01:05.796 align:middle
La primera es exactamente
lo que habíamos previsto

00:01:06.546 --> 00:01:09.596 align:middle
busca todos los starship_parts ordenados
por precio de forma descendente.

00:01:10.186 --> 00:01:12.196 align:middle
Pero espera, ¿qué son
todas estas otras consultas?

00:01:12.556 --> 00:01:14.466 align:middle
Hay una consulta más por nave.

00:01:14.886 --> 00:01:15.516 align:middle
¿Por qué?

00:01:16.126 --> 00:01:22.216 align:middle
Consultamos todas las piezas y, cuando
estamos en la plantilla repasando las piezas

00:01:22.216 --> 00:01:26.606 align:middle
y hacemos referencia a part.starship,
a Doctrine se le ilumina la bombilla.

00:01:26.976 --> 00:01:31.446 align:middle
Se da cuenta de que tiene los datos de part,
pero no los de Starship para este part.

00:01:31.706 --> 00:01:33.036 align:middle
Así que los consulta.

00:01:33.506 --> 00:01:36.346 align:middle
Al final tenemos una consulta para
las partes y una consulta adicional

00:01:36.346 --> 00:01:38.596 align:middle
para cada Starship para obtener sus partes.

00:01:39.246 --> 00:01:42.716 align:middle
Se trata de un villano conocido
como el problema N + 1.

00:01:43.246 --> 00:01:47.626 align:middle
Piénsalo así: si tenemos 10 partes,
acabaremos con una consulta para las partes

00:01:47.986 --> 00:01:51.876 align:middle
y luego 10 consultas extra, una para
el Starship de cada una de esas partes.

00:01:52.586 --> 00:01:54.116 align:middle
Esto es un problema de rendimiento.

00:01:54.116 --> 00:01:57.466 align:middle
Puede que no parezca gran cosa,
pero es algo que debemos vigilar.

00:01:57.696 --> 00:01:59.316 align:middle
Y podemos vencerlo con un join.

00:02:00.026 --> 00:02:04.596 align:middle
De vuelta en StarshipPartRepository, vamos a
potenciar findAllOrderedByPrice() con una unión.

00:02:05.396 --> 00:02:08.506 align:middle
Añade innerJoin('sp.starship', 's').

00:02:09.126 --> 00:02:11.736 align:middle
Todo lo que tenemos que hacer
es unir en la propiedad.

00:02:12.156 --> 00:02:15.706 align:middle
Doctrine averiguará los detalles por
nosotros, como en qué columnas unir.

00:02:16.256 --> 00:02:22.256 align:middle
A continuación, pasaremos toda la tabla starship a
s: Antes teníamos 9 consultas a la base de datos.

00:02:22.656 --> 00:02:24.326 align:middle
Actualizar y...

00:02:24.326 --> 00:02:26.496 align:middle
seguimos teniendo 9
consultas a la base de datos.

00:02:27.126 --> 00:02:30.056 align:middle
¿Por qué? ¿No nos habíamos
unido ya a la tabla starship?

00:02:30.646 --> 00:02:33.266 align:middle
Sí, pero hay dos razones para utilizar join.

00:02:33.656 --> 00:02:36.096 align:middle
La primera es evitar este problema de N + 1,

00:02:36.576 --> 00:02:40.136 align:middle
y la segunda es hacer una where()
o orderBy() en la tabla de unión.

00:02:40.626 --> 00:02:42.246 align:middle
Pronto exploraremos esta segunda razón.

00:02:42.766 --> 00:02:45.796 align:middle
Para resolver el problema de
N más 1, además del join,

00:02:46.046 --> 00:02:48.176 align:middle
necesitamos seleccionar los datos en Starship.

00:02:48.656 --> 00:02:54.636 align:middle
Es tan sencillo como decir addSelect('s'): Estamos
aliasando toda la tabla Starship a s. Luego,

00:02:54.636 --> 00:02:57.516 align:middle
con addSelect(), no nos molestamos
con las columnas individuales.

00:02:57.876 --> 00:03:00.246 align:middle
Simplemente decimos: Quiero todos esos datos.

00:03:01.126 --> 00:03:03.906 align:middle
De 9 consultas a la base de
datos, sólo nos queda 1.

00:03:04.396 --> 00:03:06.436 align:middle
Eso sí que es magia.

00:03:07.346 --> 00:03:11.016 align:middle
Como puedes ver, estamos seleccionando
en StarshipPart, cogiendo todos los datos

00:03:11.016 --> 00:03:15.286 align:middle
de Starship y StarshipPart,
con innerJoin() justo ahí.

00:03:16.096 --> 00:03:16.746 align:middle
¿Y lo mejor?

00:03:16.986 --> 00:03:19.776 align:middle
No tenemos que preocuparnos por los
detalles de unir en qué columnas.

00:03:20.196 --> 00:03:22.636 align:middle
Todo lo que tenemos que hacer es
unir en la propiedad de relación

00:03:22.936 --> 00:03:25.766 align:middle
, y Doctrine se encarga de los
detalles aburridos por nosotros.

00:03:26.616 --> 00:03:29.036 align:middle
A continuación, vamos a añadir
una búsqueda a nuestra página.

00:03:29.426 --> 00:03:32.166 align:middle
Cuando lo hagamos, veremos
el segundo uso de JOIN

00:03:32.486 --> 00:03:34.666 align:middle
y, por último, jugaremos
con el objeto Request.
