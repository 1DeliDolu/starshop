WEBVTT

00:00:01.086 --> 00:00:03.486 align:middle
Haz clic en una nave estelar "en progreso".

00:00:04.186 --> 00:00:07.306 align:middle
A continuación, abre:
templates/starship/show.html.twig.

00:00:07.856 --> 00:00:11.236 align:middle
Para listar las piezas,
utiliza for part in ship.parts.

00:00:11.236 --> 00:00:12.756 align:middle
Esto funcionará a las mil maravillas.

00:00:13.226 --> 00:00:16.846 align:middle
Pero con una pega: el orden de
las piezas no está garantizado.

00:00:17.286 --> 00:00:20.136 align:middle
¡Salen de la base de datos
en el orden que quieran!

00:00:20.516 --> 00:00:22.436 align:middle
Preferiría tenerlas ordenadas por nombre.

00:00:22.956 --> 00:00:25.256 align:middle
¿Significa esto que tenemos que
escribir una consulta personalizada...

00:00:25.456 --> 00:00:27.746 align:middle
y ya no podemos utilizar
nuestro práctico ship.parts?

00:00:27.746 --> 00:00:29.536 align:middle
¡No temáis, amigos!

00:00:29.536 --> 00:00:31.436 align:middle
¡Aprendamos algunos trucos!

00:00:31.436 --> 00:00:33.936 align:middle
Dirígete a la entidad Starship
y busca la propiedad parts.

00:00:34.856 --> 00:00:40.046 align:middle
Encima de parts, añade un nuevo atributo:
#[ORM\OrderBy(['name' => 'ASC'])],

00:00:40.616 --> 00:00:44.336 align:middle
no position: Actualiza
la página, ¡y ya está!

00:00:44.436 --> 00:00:48.186 align:middle
Si te estás rascando la cabeza
preguntándote por qué T va antes que c,

00:00:48.446 --> 00:00:49.826 align:middle
no has olvidado el abecedario.

00:00:49.826 --> 00:00:53.876 align:middle
Es que Postgres es una base de datos que
distingue entre mayúsculas y minúsculas.

00:00:53.876 --> 00:00:58.976 align:middle
Así que la T mayúscula aparentemente va
antes que la C minúscula en orden alfabético.

00:00:59.686 --> 00:01:02.876 align:middle
Comprueba las consultas de esta
página y mira el SQL formateado.

00:01:03.836 --> 00:01:07.636 align:middle
Consulta desde starship_part, donde
starship_id es igual a nuestro ID, ordenado

00:01:07.926 --> 00:01:11.816 align:middle
por name de forma ascendente: ¡es
exactamente la consulta que queremos!

00:01:12.526 --> 00:01:17.356 align:middle
Vuelve a la página de inicio y abre su
plantilla: templates/main/homepage.html.twig.

00:01:17.356 --> 00:01:27.016 align:middle
Después de "llegado", añade un div e imprime
el recuento de piezas: ship.parts|length:

00:01:27.016 --> 00:01:29.826 align:middle
De vuelta a la página principal,
funciona a las mil maravillas.

00:01:30.366 --> 00:01:33.256 align:middle
Echa un vistazo a las consultas
de esta página, son interesantes.

00:01:33.256 --> 00:01:37.586 align:middle
Algunas parecen un poco locas debido a
nuestra paginación, pero esencialmente,

00:01:37.586 --> 00:01:42.086 align:middle
tenemos una consulta para la nave
estelar , y si buscamos starship_part,

00:01:42.856 --> 00:01:46.016 align:middle
hay 5 consultas adicionales para
las piezas de cada nave estelar.

00:01:46.616 --> 00:01:51.836 align:middle
Esto es lo que ocurre: cogemos las naves
estelares, y en cuanto contamos ship.parts,

00:01:51.836 --> 00:01:54.586 align:middle
Doctrine se da cuenta de que
aún no tiene esos datos.

00:01:55.056 --> 00:01:59.306 align:middle
Así que busca una a una todas las
piezas de cada nave y las cuenta.

00:01:59.306 --> 00:02:03.206 align:middle
Ésta es una situación habitual:
tenemos una consulta para las naves

00:02:03.396 --> 00:02:06.616 align:middle
y luego una consulta adicional
para las piezas de cada nave.

00:02:07.106 --> 00:02:11.086 align:middle
Se conoce como el problema
N+1: 1 consulta para las naves

00:02:11.086 --> 00:02:13.416 align:middle
y N consultas para las piezas de cada nave.

00:02:13.916 --> 00:02:16.506 align:middle
Es un problema menor de rendimiento
que abordaremos más adelante.

00:02:17.076 --> 00:02:18.826 align:middle
¡Pero aquí hay un problema mayor!

00:02:19.286 --> 00:02:22.766 align:middle
Consultamos cada starship_part
sólo para contarlas.

00:02:23.316 --> 00:02:26.786 align:middle
No necesitamos los datos de las piezas,
sólo necesitamos saber cuántas tenemos.

00:02:27.236 --> 00:02:28.126 align:middle
Esto es menor...

00:02:28.126 --> 00:02:30.516 align:middle
hasta que tienes una nave
con un montón de piezas.

00:02:30.516 --> 00:02:36.206 align:middle
Para solucionarlo, en el OneToMany en la entidad
Starship, añade una opción fetch establecida

00:02:36.206 --> 00:02:40.276 align:middle
en EXTRA_LAZY: ¡Vamos a ver qué ha hecho!

00:02:40.656 --> 00:02:41.676 align:middle
Vuelve a la página de inicio.

00:02:42.126 --> 00:02:43.836 align:middle
Antes teníamos nueve consultas...

00:02:44.156 --> 00:02:48.706 align:middle
¿Ahora? Siguen siendo nueve consultas,
pero la consulta de las piezas ha cambiado.

00:02:48.706 --> 00:02:52.496 align:middle
En lugar de consultar todos
sus datos, sólo los cuenta.

00:02:52.866 --> 00:02:53.796 align:middle
Mucho más inteligente, ¿verdad?

00:02:53.796 --> 00:02:59.526 align:middle
Te estarás preguntando -yo ciertamente lo hice- por
qué no utilizamos fetch="EXTRA_LAZY" todo el tiempo

00:02:59.526 --> 00:03:03.646 align:middle
En primer lugar, se trata de una pequeña optimización
del rendimiento de la que no tienes que preocuparte

00:03:03.646 --> 00:03:07.156 align:middle
, a menos que tengas una nave llena
de piezas y sólo quieras contarlas.

00:03:07.806 --> 00:03:10.316 align:middle
Y lo que es más importante,
dependiendo de si cuentas

00:03:10.316 --> 00:03:13.546 align:middle
o haces un bucle sobre las piezas primero,
esto podría causar una consulta extra.

00:03:14.426 --> 00:03:15.876 align:middle
¡Pasemos al siguiente reto!

00:03:16.396 --> 00:03:20.726 align:middle
¿Qué pasa si sólo queremos las piezas relacionadas
de una nave que cuestan más de un precio determinado?

00:03:21.156 --> 00:03:25.336 align:middle
¿Podemos seguir utilizando el acceso directo de
ship.parts o tenemos que hacer una consulta personalizada?

00:03:25.336 --> 00:03:29.616 align:middle
Permanece atento, vamos a explorar el
sistema de criterios a continuación.
