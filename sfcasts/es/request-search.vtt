WEBVTT

00:00:00.036 --> 00:00:04.726 align:middle
Ha llegado el momento de desviarse rápida
pero útilmente de las Relaciones Doctrine.

00:00:05.326 --> 00:00:07.866 align:middle
Sé que las Relaciones Doctrine
molan, ¡pero esto también!

00:00:08.336 --> 00:00:10.176 align:middle
Quiero añadir una barra de
búsqueda a nuestra página.

00:00:10.646 --> 00:00:12.776 align:middle
Confía en mí, esto va a ser bueno.

00:00:13.416 --> 00:00:16.206 align:middle
Abre la plantilla index.html.twig.

00:00:16.756 --> 00:00:22.586 align:middle
Justo en la parte superior, pegaré una entrada de búsqueda:
Nada del otro mundo: sólo un <input type="text"

00:00:22.586 --> 00:00:25.736 align:middle
"placeholder="search", y
luego un puñado de clases

00:00:25.736 --> 00:00:28.146 align:middle
y un elegante SVG para que quede bonito.

00:00:28.836 --> 00:00:31.556 align:middle
Para que este chico malo se envíe,
envuélvelo en una etiqueta form.

00:00:32.906 --> 00:00:38.946 align:middle
Para la acción, haz que se envíe directamente
a esta página: {{ path('app_part_index') }}.

00:00:38.946 --> 00:00:44.696 align:middle
Añade también name="query" y method="get" al
formulario: De esta forma, cuando enviemos el formulario

00:00:44.936 --> 00:00:47.986 align:middle
, añadirá la consulta de búsqueda
a la URL como parámetro de consulta.

00:00:52.826 --> 00:00:54.106 align:middle
A continuación, dirígete a PartController.

00:00:54.516 --> 00:00:57.536 align:middle
¿Cómo leemos el parámetro
de consulta name de la URL?

00:00:58.116 --> 00:01:02.896 align:middle
Bueno, es información de la petición, igual que
las cabeceras de la petición o los datos POST.

00:01:02.896 --> 00:01:06.916 align:middle
Symfony empaqueta todo
eso en un objeto Request.

00:01:07.376 --> 00:01:08.216 align:middle
¿Cómo lo obtenemos?

00:01:08.626 --> 00:01:10.596 align:middle
En un controlador, es superfácil.

00:01:11.196 --> 00:01:13.376 align:middle
Añade un argumento Request
al método de tu controlador.

00:01:14.096 --> 00:01:17.106 align:middle
Probablemente recuerdes que puedes
autoconectar servicios de este modo.

00:01:17.526 --> 00:01:20.386 align:middle
El objeto Request no es
técnicamente un servicio,

00:01:20.386 --> 00:01:23.236 align:middle
pero Symfony es lo suficientemente guay como
para permitir autocablearlo de todas formas.

00:01:23.746 --> 00:01:27.806 align:middle
Coge el de
Symfony\Component\HttpFoundation\Request.

00:01:28.406 --> 00:01:32.906 align:middle
Puedes llamarlo como quieras, pero para
mantener la cordura, vamos a llamarlo $request:

00:01:32.906 --> 00:01:39.836 align:middle
Establece $query = $request->query->get('query'):
el primer query se refiere a los parámetros de consulta,

00:01:40.286 --> 00:01:42.676 align:middle
y el segundo query es el
nombre del campo de entrada.

00:01:43.386 --> 00:01:47.816 align:middle
Para asegurarte de que funciona,
dd($query): Gira y pruébalo.

00:01:48.686 --> 00:01:49.426 align:middle
¡Fíjate!

00:01:49.426 --> 00:01:50.736 align:middle
Es la cadena "holodeck".

00:01:50.736 --> 00:01:55.606 align:middle
A continuación, vamos a mejorar el método
findAllOrderedByPrice() para permitir una búsqueda.

00:01:56.106 --> 00:01:58.586 align:middle
Elimina el dd($query); y pásalo al método:

00:02:04.816 --> 00:02:07.916 align:middle
Divídelo en varias líneas
y añade una sentencia if.

00:02:08.426 --> 00:02:14.216 align:middle
También voy a cambiar el retorno a $qb =
$this->createQueryBuilder('sp') y a deshacerme

00:02:14.216 --> 00:02:18.076 align:middle
de getQuery() y getResult(): por
ahora sólo queremos QueryBuilder.

00:02:19.056 --> 00:02:20.306 align:middle
Ahora viene la magia.

00:02:20.686 --> 00:02:25.776 align:middle
Si tenemos una búsqueda, añade un andWhere()
que compruebe si el nombre en minúsculas

00:02:25.776 --> 00:02:28.166 align:middle
de nuestra parte Starship
es como nuestra búsqueda.

00:02:28.826 --> 00:02:33.256 align:middle
Ya sé que parece un poco raro, pero es porque
PostgreSQL distingue entre mayúsculas y minúsculas.

00:02:33.256 --> 00:02:36.686 align:middle
Por último, devuelve el
resultado de la consulta:

00:02:36.686 --> 00:02:42.476 align:middle
Puedes observar que perdemos nuestro valor
de búsqueda después de una búsqueda.

00:02:42.956 --> 00:02:46.146 align:middle
Ya no vemos "holodeck" ahí,
y eso es una grosería.

00:02:46.146 --> 00:02:54.576 align:middle
Para solucionarlo, de vuelta en la plantilla, añade
un value="{{ app.request.query.get('query') }}".

00:02:56.616 --> 00:03:01.416 align:middle
Sí, ese práctico objeto Request está disponible
en cualquier plantilla como app.request:

00:03:03.296 --> 00:03:06.456 align:middle
¿No sería genial poder buscar
también en las notas de las piezas?

00:03:06.456 --> 00:03:07.716 align:middle
Busca 'controles'.

00:03:08.416 --> 00:03:09.536 align:middle
Ahora mismo, nada.

00:03:10.056 --> 00:03:12.526 align:middle
Realmente queremos buscar
en el nombre y en las notas.

00:03:12.956 --> 00:03:14.486 align:middle
Necesitamos algo de lógica OR.

00:03:14.986 --> 00:03:20.276 align:middle
De vuelta al repositorio, añade un OR a la
cláusula andWhere(): Podrías tener la tentación

00:03:20.276 --> 00:03:22.746 align:middle
de utilizar orWhere(),
¡pero eso es una trampa!

00:03:23.096 --> 00:03:25.936 align:middle
No puedes garantizar dónde
estarán los paréntesis lógicos.

00:03:26.326 --> 00:03:27.746 align:middle
Confía en mí, me lo agradecerás más tarde.

00:03:28.276 --> 00:03:32.706 align:middle
En lugar de eso, utiliza andWhere()
y coloca el OR justo dentro.

00:03:32.706 --> 00:03:33.516 align:middle
¡Y ya lo tenemos!

00:03:33.786 --> 00:03:37.756 align:middle
Ahora podemos buscar en las
notas, en el nombre, o en ambos.

00:03:37.756 --> 00:03:42.936 align:middle
La conclusión es que cuando quieras utilizar orWhere(),
no lo hagas: incrusta el OR dentro de un andWhere(),

00:03:42.936 --> 00:03:46.306 align:middle
y tendrás pleno control sobre
dónde van los paréntesis lógicos.

00:03:47.226 --> 00:03:50.796 align:middle
Bien, una vez completado este emocionante
desvío, volvamos al tema y hablemos

00:03:50.796 --> 00:03:53.786 align:middle
del último tipo de
relación: de muchos a muchos.
