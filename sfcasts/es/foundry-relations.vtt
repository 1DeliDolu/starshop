WEBVTT

00:00:01.056 --> 00:00:03.826 align:middle
Vale, tenemos un par de piezas
y unas cuantas naves estelares,

00:00:04.166 --> 00:00:07.936 align:middle
pero para llenar nuestra flota de
datos de pruebas: Quiero mucho más.

00:00:08.466 --> 00:00:12.166 align:middle
Éste es un trabajo perfectamente
adecuado para nuestro buen amigo Foundry.

00:00:12.856 --> 00:00:19.266 align:middle
Elimina el código manual y, en cualquier
lugar, di: StarshipPartFactory::createMany(100):

00:00:20.496 --> 00:00:26.896 align:middle
Y prueba los accesorios: symfony
console doctrine:fixtures:load ¡Uh-oh!

00:00:27.256 --> 00:00:30.036 align:middle
starship_id no puede ser nulo en starship_part.

00:00:30.646 --> 00:00:32.166 align:middle
Esto se remonta

00:00:32.166 --> 00:00:35.536 align:middle
hasta StarshipPartFactory,
en el método defaults().

00:00:36.026 --> 00:00:39.866 align:middle
Estos son los datos que se pasan a
cada nuevo StarshipPart cuando se crea.

00:00:40.426 --> 00:00:45.576 align:middle
La regla de oro es hacer que defaults() devuelva
una clave para cada propiedad necesaria del objeto.

00:00:46.026 --> 00:00:49.756 align:middle
Ahora mismo, obviamente nos falta la propiedad
starship, así que vamos a añadirla.

00:00:50.276 --> 00:00:56.576 align:middle
Establece starship, no starship_id, en un método
ingenioso llamado Starship::randomOrCreate()

00:00:56.976 --> 00:01:00.806 align:middle
y pásale un array: En la página
de inicio, sólo listamos las naves

00:01:00.806 --> 00:01:03.136 align:middle
con estado "en curso" o "en espera".

00:01:03.656 --> 00:01:06.796 align:middle
Para asegurarnos de que estas piezas están
relacionadas con una nave con estado "en progreso",

00:01:07.096 --> 00:01:12.136 align:middle
añade una clave status en el array
establecido en StarshipStatusEnum::IN_PROGRESS:

00:01:12.926 --> 00:01:17.506 align:middle
Este randomOrCreate() es un método
impresionante: primero busca en la base de

00:01:17.506 --> 00:01:21.746 align:middle
datos un Starship que coincida con estos
criterios (una nave "en progreso").

00:01:22.206 --> 00:01:24.076 align:middle
Si encuentra una, la utiliza.

00:01:24.486 --> 00:01:27.456 align:middle
Si no, crea una con ese estado.

00:01:28.146 --> 00:01:29.316 align:middle
Prueba ahora los accesorios.

00:01:31.216 --> 00:01:32.166 align:middle
¡No hay errores!

00:01:32.666 --> 00:01:36.626 align:middle
Comprueba la base de datos: symfony
console doctrine:query:sql "SELECT *

00:01:36.856 --> 00:01:39.696 align:middle
FROM starship_part" Fíjate bien...

00:01:40.426 --> 00:01:44.206 align:middle
Vale! tenemos 100 piezas, cada una
vinculada a un Starship aleatorio,

00:01:44.516 --> 00:01:47.456 align:middle
que debería ser un Starship
con estado "en curso".

00:01:47.966 --> 00:01:50.436 align:middle
¡Creo que han sido mis 5
minutos más productivos!

00:01:50.996 --> 00:01:52.736 align:middle
Pero, ¿y si necesitamos más control?

00:01:52.966 --> 00:01:56.936 align:middle
¿Y si queremos asignar las
100 piezas a la misma nave?

00:01:57.676 --> 00:01:59.566 align:middle
Sé que suena un poco inútil

00:01:59.656 --> 00:02:03.006 align:middle
, pero nos ayudará a entender
mejor Foundry y las relaciones.

00:02:03.776 --> 00:02:09.716 align:middle
Empieza por obtener una variable de nave:
$ship = StarshipFactory::createOne(): Luego,

00:02:09.716 --> 00:02:14.866 align:middle
en StarshipPartFactory::createMany(), pasa un segundo
argumento para especificar que queremos que starship

00:02:14.866 --> 00:02:19.606 align:middle
se fije en esta nave concreta:
Vuelve a cargar los accesorios.

00:02:20.236 --> 00:02:25.736 align:middle
Y ¡listo! Ahora todas las piezas
están relacionadas con la misma nave.

00:02:26.296 --> 00:02:32.666 align:middle
Y si consultamos el Starship, tenemos 23: las 20
de abajo, más las 3 extra que hemos añadido.

00:02:32.936 --> 00:02:34.336 align:middle
¡Todo está encajando!

00:02:35.026 --> 00:02:37.226 align:middle
Aquí es donde las cosas se ponen interesantes.

00:02:37.716 --> 00:02:41.446 align:middle
En StarshipPartFactory, en lugar
de utilizar randomOrCreate(),

00:02:41.616 --> 00:02:44.916 align:middle
cambia a createOne(): Vuelve
a cargar las instalaciones.

00:02:44.916 --> 00:02:48.666 align:middle
Y... consulta todas las naves.

00:02:49.356 --> 00:02:51.446 align:middle
Vaya, ¡de repente tenemos una flota!

00:02:51.816 --> 00:02:54.806 align:middle
123 naves para ser exactos.

00:02:55.286 --> 00:02:55.946 align:middle
¿Qué ha pasado?

00:02:56.756 --> 00:02:58.936 align:middle
Para cada pieza, se llama a defaults().

00:02:59.296 --> 00:03:04.276 align:middle
Así que para las 100 piezas, se está activando
esta línea, que crea y guarda un Starship,

00:03:04.606 --> 00:03:08.406 align:middle
aunque nunca utilicemos ese Starship
porque lo anulamos momentos después.

00:03:09.046 --> 00:03:09.896 align:middle
¿La solución?

00:03:10.146 --> 00:03:16.866 align:middle
Cambiar esto por StarshipFactory::new(): Esta
es la salsa secreta: crea una nueva instancia

00:03:16.866 --> 00:03:19.836 align:middle
de la fábrica, no un
objeto en la base de datos.

00:03:20.506 --> 00:03:26.136 align:middle
Pruébalo: symfony console
doctrine:fixtures:load Consulta las naves.

00:03:27.096 --> 00:03:28.996 align:middle
¡Perfecto! Volvemos a tener 23.

00:03:29.816 --> 00:03:34.836 align:middle
¡Dato curioso! Podemos utilizar estas instancias
de fábrica como recetas para crear objetos.

00:03:35.296 --> 00:03:40.656 align:middle
StarshipFactory::new(['status' =>
StarshipStatusEnum::STATUS_IN_PROGRESS])

00:03:40.656 --> 00:03:42.676 align:middle
no crea un objeto en la base de datos.

00:03:43.126 --> 00:03:45.806 align:middle
No: new() significa una nueva
instancia de la fábrica.

00:03:46.376 --> 00:03:50.156 align:middle
Y cuando pasas una fábrica para una
propiedad, Foundry retrasa la creación de

00:03:50.156 --> 00:03:52.566 align:middle
ese objeto hasta que se
necesite, si es que se necesita.

00:03:53.046 --> 00:03:57.036 align:middle
Por tanto, sólo si no se anula
Starship creará un nuevo Starship

00:03:57.076 --> 00:03:58.916 align:middle
con el estado "en curso" y lo guardará.

00:03:59.556 --> 00:04:02.276 align:middle
En realidad, ésta es la mejor práctica
a la hora de establecer relaciones

00:04:02.276 --> 00:04:05.276 align:middle
en Foundry: establecerlas en
una instancia de fábrica.

00:04:06.016 --> 00:04:10.766 align:middle
Limpia nuestras instalaciones
eliminando la anulación: Y...

00:04:10.766 --> 00:04:15.866 align:middle
vuelve a randomOrCreate() Porque, seamos
sinceros, es un método bastante útil.

00:04:17.116 --> 00:04:21.636 align:middle
Recarga los dispositivos una última vez
para asegurarte de que no hemos roto nada

00:04:21.956 --> 00:04:23.236 align:middle
Nos esforzaremos más la próxima vez.
