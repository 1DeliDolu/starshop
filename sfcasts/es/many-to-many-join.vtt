WEBVTT

00:00:01.086 --> 00:00:04.596 align:middle
¿Te has preguntado alguna vez qué nave
de la flota está plagada de más droides?

00:00:04.976 --> 00:00:10.006 align:middle
Yo también Hagamos una lista de todas las naves
en orden ascendente según su número de droides.

00:00:10.656 --> 00:00:12.636 align:middle
Sumérgete en
src/Controller/MainController.php.

00:00:12.636 --> 00:00:17.496 align:middle
La consulta es: $ships =
$repository->findIncomplete();.

00:00:18.056 --> 00:00:23.296 align:middle
Haz clic en ese método y dale un nombre nuevo
y elegante: findIncompleteOrderedByDroidCount():

00:00:23.886 --> 00:00:28.166 align:middle
Cópialo, vuelve al controlador y
sustituye el método antiguo por el nuevo:

00:00:28.896 --> 00:00:32.596 align:middle
Aún no hemos cambiado nada, así que una
actualización rápida nos da lo mismo.

00:00:33.326 --> 00:00:38.456 align:middle
Para ordenar las naves estelares por su número
de droides, tenemos que unir la tabla de unión

00:00:38.456 --> 00:00:41.736 align:middle
hasta droid, agrupar por starship,
y luego contar los droides.

00:00:42.156 --> 00:00:44.746 align:middle
Guau. En realidad, ¡es bastante bonito!

00:00:45.226 --> 00:00:47.726 align:middle
En StarshipRepository, añade un leftJoin().

00:00:48.236 --> 00:00:51.396 align:middle
Pero no vamos a pensar en la tabla
de unión ni en la base de datos.

00:00:52.076 --> 00:00:55.126 align:middle
No, céntrate sólo en las
relaciones en Doctrine.

00:00:55.726 --> 00:00:59.416 align:middle
Así que estamos uniendo a través de s,
que es nuestra nave estelar, y droids,

00:00:59.416 --> 00:01:02.596 align:middle
la propiedad que tiene la
relación ManyToMany con Droid.

00:01:03.336 --> 00:01:05.596 align:middle
Por último, aliasamos esos droides como droid.

00:01:06.526 --> 00:01:09.426 align:middle
Para contar los droides,
añade un groupBy('s.id').

00:01:10.346 --> 00:01:15.406 align:middle
Para ordenar sustituye el orderBy()
existente por orderBy('COUNT(droid)', 'ASC'):

00:01:16.556 --> 00:01:19.686 align:middle
Después, pulsa actualizar y ¡boom!

00:01:19.686 --> 00:01:21.826 align:middle
En la parte superior, verás droids none.

00:01:22.186 --> 00:01:24.806 align:middle
Pero a medida que te desplazas hacia
abajo, el recuento de droides aumenta.

00:01:25.496 --> 00:01:29.486 align:middle
Si eres lo suficientemente valiente como para aventurarte unas
páginas más adelante, ¡empezaremos a ver naves estelares

00:01:29.486 --> 00:01:31.746 align:middle
con dos, tres o incluso cuatro droides!

00:01:32.346 --> 00:01:34.966 align:middle
¿La clave? No hay nada
especial en esta unión.

00:01:35.436 --> 00:01:38.766 align:middle
Nos unimos a través de la propiedad
y Doctrine se encarga del resto.

00:01:39.316 --> 00:01:42.936 align:middle
Si echas un vistazo a la consulta en esta página,
verás que se encarga de todos los detalles.

00:01:43.486 --> 00:01:46.436 align:middle
Busca starship_droid para
encontrar la consulta.

00:01:47.206 --> 00:01:52.286 align:middle
Es feo, pero si formateas la consulta, selecciona
de starship, encargándose de la unión

00:01:52.286 --> 00:01:55.896 align:middle
a la tabla de unión y
uniendo de nuevo a droid.

00:01:56.526 --> 00:02:00.626 align:middle
Eso nos permite contar y ordenar
por ese recuento en esa tabla droid.

00:02:01.256 --> 00:02:03.686 align:middle
Impresionante Doctrine, ¡impresionante!

00:02:04.436 --> 00:02:06.636 align:middle
¡Eso es técnicamente todo para ManyToMany!

00:02:07.026 --> 00:02:10.966 align:middle
Pero a continuación vamos a tratar un caso
de uso más avanzado, pero aún común:

00:02:11.436 --> 00:02:15.726 align:middle
añadir datos a la tabla join, como la fecha
en la que el droide se unió a la nave estelar.
